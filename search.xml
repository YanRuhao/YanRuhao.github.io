<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BZOJ3211 花神游历各国]]></title>
    <url>%2F2019%2F10%2F10%2Fbzoj-3211%2F</url>
    <content type="text"><![CDATA[BZOJ3211BZOJ 3211BZOJ3211 花神游历各国（树状数组+并查集） LuoguLuoguLuogu传送门 问题描述 给你一个序列，要求支持两种操作 把区间 [l,r][l,r][l,r] 内的所有数都开根（向下取整） 求区间 [l,r][l,r][l,r] 内所有数的和 输入描述 第一行一个整数 nnn，代表数列中数的个数。 第二行 nnn 个正整数，表示初始状态下数列中的数。 第三行一个整数 mmm，表示有 mmm 次操作。 接下来 mmm 行每行三个整数 k,l,rk,l,rk,l,r， k=0k=0k=0 表示给 [l,r][l,r][l,r] 中的每个数开平方(下取整) k=1k=1k=1 表示询问 [l,r][l,r][l,r] 中各个数的和。 数据中有可能 l&gt;rl&gt;rl&gt;r ，需要交换 lll 和 rrr。 输出描述 对于询问操作，每行输出一个回答。 输入样例 101 2 3 4 5 6 7 8 9 1050 1 101 1 101 1 50 5 81 4 8 输出样例 1976 数据范围 对于 30%30\%30% 的数据，1≤n,m≤10001\le n,m\le 10001≤n,m≤1000，数列中的数不超过 327673276732767。 对于 100%100\%100%的数据，1≤n,m≤1000001 \le n,m \le 1000001≤n,m≤100000, 1≤l,r≤1 \le l,r \le1≤l,r≤，数列中的数大于 000，且不超过 101210^{12}1012 题解 不喜欢敲线段树，刚好老师上课讲了该题的树状数组+并查集的解法，便自己动手捣鼓一下。 首先，单点修改求区间和可以用树状数组实现，因为开平方很耗时间，所以在这个方面可以优化，我们知道，开平方开几次之后数字就会等于 111 ，所以，用数组记录下一个应该开的数，每次直接跳到下一个不是1的数字进行开平方，至于这个数组，可以用并查集维护。 #include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;using namespace std;#define ll long longconst int maxn = 5e5 + 10;const int inf = 1e9 + 7;int n, m;ll a[maxn], b[maxn], f[maxn];inline ll read() &#123; ll s = 0, f = 0; char ch = getchar(); while (!isdigit(ch)) f |= ch == '-', ch = getchar(); while (isdigit(ch)) s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + (ch ^ 48), ch = getchar(); return f ? -s : s;&#125;int find(int x) &#123; if (f[x] == x) return x; else return f[x] = find(f[x]);&#125;int lowbit (int x) &#123; return x &amp; -x;&#125;void add(int i, ll x) &#123; while (i &lt;= n) b[i] += x, i += lowbit(i);&#125; ll sum (int i) &#123; ll ans = 0; while (i &gt; 0) ans += b[i], i -= lowbit(i); return ans;&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(), add(i, a[i]); for (int i = 1; i &lt;= n; i++) f[i] = i; m = read(); for (int i = 1; i &lt;= m; i++) &#123; ll k = read(), l = read(), r = read(); if (l &gt; r) swap(l, r); if(k == 0) &#123; while (l &lt;= r) &#123; ll t = sqrt(a[l]); add(l, t - a[l]); a[l] = t; if (a[l] &lt;= 1) f[l] = l + 1; else f[l] = l; if (f[l] == l) l++; else l = find(f[l]); &#125; &#125; else if(k == 1) printf("%lld\n", sum(r) - sum(l - 1)); &#125; return 0; &#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>树状数组</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭州集训Day6总结]]></title>
    <url>%2F2019%2F10%2F06%2Fhang-zhou-day6%2F</url>
    <content type="text"><![CDATA[国庆杭州集训Day6上午考试，一套奇奇怪怪的伪 USACOUSACOUSACO 的题目，（我也不知道是还没找到原题还是真的老师故意出这种题面），涵盖了数论、DPDPDP、模运算等内容，考场发挥不佳，故作总结。 T1 九九乘法表 问题描述 奶牛 BessieBessieBessie 最近在背九九乘法表，但是她发现这张表对她来说实在是太easy了，于是她打算做一张无限大的乘法表。 BessieBessieBessie 画了一个无限大的二维表格，然后在第 iii 行第 jjj 列写下了 i×ji × ji×j 的值，如下所示。 1 2 3 4 …2 4 6 8 …3 6 9 12 …4 8 12 16 …… … … … BessieBessieBessie 知道你已经精通加减乘除，于是她想让你统计这张乘法表上有多少个矩形内部的和为 SSS. 准确地说，请统计满足以第 aaa 行第 bbb 列单元格为左上角，以第 ccc 行第 ddd 列单元格为右下角的矩形内的数字之和为 SSS 的四元组 (a,b,c,d)(a≤c,b≤d)(a, b, c, d) (a ≤ c, b ≤ d)(a,b,c,d)(a≤c,b≤d) 的个数。 输入描述 输入仅一行，一个数，表示 SSS. 输出描述 一个数，表示符合要求的四元组个数。 输入样例 #111 3 #222 9 #333 20000518 输出样例 #111 4 #222 10 #333 32 样例解释 对于第一组样例，符合要求的四元组一共有 444 个：(1,1,1,2)(1,1,1,2)(1,1,1,2), (1,1,2,1)(1,1,2,1)(1,1,2,1), (1,3,1,3)(1,3,1,3)(1,3,1,3), (3,1,3,1)(3,1,3,1)(3,1,3,1). 数据范围 对于 30%30\%30% 的数据，1≤S≤1001 ≤ S ≤ 1001≤S≤100 对于 70%70\%70% 的数据，1≤S≤1061 ≤ S ≤ 10^61≤S≤106 对于 100%100\%100% 的数据，1≤S≤1091 ≤ S ≤ 10^91≤S≤109 T1 总结、题解 总结 考试的时候没仔细的去推，先是瞎敲了一个 O(n4)O(n^4)O(n4) 的暴力枚举，后面仔细想想发现可以利用等差数列来解决，但是也仅仅停留在 S=(a+c)(c−a+1)2×(b+d)(d−b+1)2S = \frac{(a+c)(c-a+ 1)}{2} \times \frac{(b + d)(d - b + 1)}{2}S=2(a+c)(c−a+1)​×2(b+d)(d−b+1)​，之后便没有想到枚举因子等操作，最终得分303030分。 题解 在九九乘法表中，不难发现给定的矩形可以有第一行对应的数字之和乘以第一列对应的数字之和，即下图中蓝色矩形数字之和为两个红色矩形数字之和的乘积。 由于红色部分为公差为 111 的等差数列，不难得出 S=(a+c)(c−a+1)2×(b+d)(d−b+1)2S = \frac{(a+c)(c-a+ 1)}{2} \times \frac{(b + d)(d - b + 1)}{2}S=2(a+c)(c−a+1)​×2(b+d)(d−b+1)​ ，我们令 P=(a+c)(c−a+1)2P = \frac{(a+c)(c-a+ 1)}{2}P=2(a+c)(c−a+1)​，有 2P=(a+c)(c−a+1)2P = (a+c)(c-a+1)2P=(a+c)(c−a+1)，则我们可以枚举 2P2P2P 的因子 hhh，令 a+c=ha + c = ha+c=h, c−a+1=2Phc - a + 1 = \frac {2P}{h}c−a+1=h2P​，即可解出 aaa, ccc，判断是否是整数且满足 1≤a≤c1 ≤ a ≤ c1≤a≤c 即可。QQQ 同理。 综上，时间复杂度为 O(SO(SO(S的因子个数×S)\times\sqrt S)×S​) 代码 #include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;using namespace std;#define ll long longconst int maxn = 2e6 + 10;const int mod = 1e9 + 7;int n, m, s, t;ll ans;inline int read() &#123; int s = 0, f = 0; char ch = getchar(); while (!isdigit(ch)) f |= ch == '-', ch = getchar(); while (isdigit(ch)) s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + (ch ^ 48), ch = getchar(); return f ? -s: s;&#125;int work(int p) &#123; int num = 0; for (int i = 1; 1ll * i * i &lt;= 1ll * p; i++) &#123; if (p % i == 0) &#123; int c = p / i + i - 1, a = p - c / 2; if (c % 2 == 1) continue; if (a &gt;= 1) num++; &#125; &#125; return num;&#125;int main() &#123; freopen("table.in", "r", stdin); freopen("table.out", "w", stdout); s = read(); for (int i = 1; i * i &lt;= s; i++) &#123; if (s % i != 0) continue; ll num = 1ll * work(2 * i) * work(2 * s / i); ans += num; if (i * i &lt; s) ans += num; &#125; printf("%lld\n", ans); return 0;&#125; T2 电梯调度 问题描述 FarmerJohnFarmer JohnFarmerJohn 有一幢 HHH 层的大楼，里面有三部电梯。现在我们提前得知了 nnn 头牛要依次使用电梯通行的消息。 每条消息都由二元组 (s,t)(s≠t)(s, t)(s \ne t)(s,t)(s​=t) 表示，第 iii 条消息 (si,ti)(s_i, t_i)(si​,ti​) 表示第 iii 头牛要从第 sis_isi​ 层坐电梯移动到第 tit_iti​ 层。并且，当第 iii 头牛要乘坐电梯时，一定保证前面的 (i−1)(i - 1)(i−1) 头牛都已经到达了各自的目标楼层。 电梯每移动一层的高度，就需要花费 111 个单位的电量。请你安排一种调度方案，使得三部电梯的耗电量之和最小。 你的调度方案应当包括两方面的信息：（1）三台电梯的初始位置，这可以是任意楼层。（2）对于每头牛，你都要指定一台电梯来运送他。 最后你只需要给出最小的耗电量之和即可。 输入描述 输入第一行，两个整数 nnn 和 HHH； 接下来 nnn 行，每行两个整数 sis_isi​ 和 tit_iti​。 输出描述 输出一个数，表示最少的耗电量。 输入样例 4 66 13 52 42 1 输出样例 11 样例解释 最佳的调度方案为：第一台电梯初始停在 666 层，第二台电梯初始停在 333 层，第三台电梯初始停在 222 层；第一台电梯运送第 111、444 头牛，第二台电梯运送第 222 头牛，第三台电梯运送第 333头牛。 对于第一头牛，第一台电梯把他从 666 楼运到 111 楼，耗费 555 单位电量； 对于第二头牛，第二台电梯把他从 333 楼运到 555 楼，耗费 222 单位电量； 对于第三头牛，第三台电梯把他从 222 楼运到 444 楼，耗费 222 单位电量； 对于第四头牛，第一台电梯从 111 楼移动到 222 楼，再把他从 222 楼运到 111 楼，耗费 1+1=21+1=21+1=2 单位电量； 一共耗费 5+2+2+2=115+2+2+2=115+2+2+2=11 单位电量，可以证明这是耗电量之和最小的方案。 数据范围 对于 20%20\%20% 的数据，1≤n,H≤71 ≤ n, H ≤ 71≤n,H≤7； 对于 50%50\%50% 的数据，1≤n,H≤501 ≤ n, H ≤ 501≤n,H≤50； 对于 100%100\%100% 的数据，1≤n,H≤300,1≤si,ti≤H1 ≤ n, H ≤ 300, 1 ≤ s_i, t_i ≤ H1≤n,H≤300,1≤si​,ti​≤H. T2 总结、题解 总结 算是一个简单的DP吧，考试的时候脑抽没想到，一直在想最短路之类的诡异算法，最后还没搞出来，草草敲爆搜，卑微至极。 题解 由题易得，因为当第 iii 头牛来坐电梯时，前 i−1i - 1i−1 头牛已经到达了各自的目标楼层，故对后面的牛不产生任何影响，于是可以考虑动态规划。我们令 f[i][j][k][l]f[i][j][k][l]f[i][j][k][l] 表示当前处理到第 iii 头牛，第一台电梯停在 jjj 层，第二台电梯停在 kkk 层，第三台电梯停在 lll 层。当考虑第 i+1i + 1i+1 头牛时，对于若可分配的三台电梯，有： 第一台电梯： f[i+1][ti+1][k][l]=f[i][j][k][l]+∣j−si+1∣+∣si+1−ti+1∣f[i + 1][t_{i+1}][k][l] = f[i][j][k][l] + |j - s_{i+1}| + |s_{i+1} - t_{i+1}|f[i+1][ti+1​][k][l]=f[i][j][k][l]+∣j−si+1​∣+∣si+1​−ti+1​∣ 第二台电梯： f[i+1][j][ti+1][l]=f[i][j][k][l]+∣k−si+1∣+∣si+1−ti+1∣f[i + 1][j][t_{i+1}][l] = f[i][j][k][l] + |k - s_{i+1}| + |s_{i+1} - t_{i+1}|f[i+1][j][ti+1​][l]=f[i][j][k][l]+∣k−si+1​∣+∣si+1​−ti+1​∣ 第三台电梯： f[i+1][j][k][ti+1]=f[i][j][k][l]+∣l−si+1∣+∣si+1−ti+1∣f[i + 1][j][k][t_{i+1}] = f[i][j][k][l] + |l - s_{i+1}| + |s_{i+1} - t_{i+1}|f[i+1][j][k][ti+1​]=f[i][j][k][l]+∣l−si+1​∣+∣si+1​−ti+1​∣ 可以看到这样状态数有 O(nH3)O(nH^3)O(nH3)，转移是 O(1)O(1)O(1) 的。时间复杂度为 O(nH3)O(nH^3)O(nH3)。于是 50pts50pts50pts 到手。 考虑优化，我们可以注意到在第 iii 头牛到达目标楼层之后，一定有一台电梯停在第 tit_iti​ 层，所以有一维状态可以去掉。即用 f[i][j][k]f[i][j][k]f[i][j][k] 表示当前处理到第 iii 头牛，其中一台电梯停在 jjj 层，一台电梯停在 kkk 层，另一台电梯停在 tit_iti​ 层。则对于第 i+1i + 1i+1 头牛的分配情况，有： 第一台电梯：f[i+1][ti][k]=f[i+1][k][ti]=f[i][j][k]+∣j−si+1∣+∣si+1−ti+1∣f[i + 1][t_i][k] = f[i + 1][k][t_i] = f[i][j][k] + |j - s_{i+1}| + |s_{i+1} - t_{i+1}|f[i+1][ti​][k]=f[i+1][k][ti​]=f[i][j][k]+∣j−si+1​∣+∣si+1​−ti+1​∣ 第二台电梯：f[i+1][j][ti]=f[i+1][ti][j]=f[i][j][k]+∣k−si+1∣+∣si+1−ti+1∣f[i + 1][j][t_i] = f[i + 1][t_i][j] = f[i][j][k] + |k - s_{i+1}| + |s_{i+1} - t_{i+1}|f[i+1][j][ti​]=f[i+1][ti​][j]=f[i][j][k]+∣k−si+1​∣+∣si+1​−ti+1​∣ 第三台电梯：f[i+1][j][k]=f[i+1][k][j]=f[i][j][k]+∣ti−si+1∣+∣si+1−ti+1∣f[i + 1][j][k] = f[i + 1][k][j] = f[i][j][k] + |t_i - s_{i+1}| + |s_{i+1} - t_{i+1}|f[i+1][j][k]=f[i+1][k][j]=f[i][j][k]+∣ti​−si+1​∣+∣si+1​−ti+1​∣ 。 这样状态数就优化到了 O(nH2)O(nH^2)O(nH2)，转移是 O(1)O(1)O(1) 的。时间复杂度为 O(nH2)O(nH^2)O(nH2)。 用滚动数组可以把第一维压缩掉，将空间复杂度优化到 O(H2)O(H^2)O(H2)。 代码 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;#include &lt;cctype&gt;using namespace std;const int maxn = 300 + 10;const int inf = 1e9 + 7;int n, h, ans = inf, sum;int s[maxn], t[maxn], f[2][maxn][maxn];inline int read() &#123; int s = 0, f = 0; char ch = getchar(); while (!isdigit(ch)) f |= ch == '-', ch = getchar(); while (isdigit(ch)) s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + (ch ^ 48), ch = getchar(); return f ? -s: s;&#125;int main() &#123; freopen("schedudle.in", "r", stdin); freopen("schedule.out", "w", stdout); n = read(), h = read(); for (int i = 1; i &lt;= n; i++) &#123; s[i] = read(), t[i] = read(); sum += abs(s[i] - t[i]); &#125; for (int i = 1; i &lt; n ; i++) &#123; int p = (i &amp; 1); memset(f[p ^ 1], 0x3f, sizeof f[p ^ 1]); for (int j = 1 ; j &lt;= h; j++) &#123; for (int k = 1; k &lt;= h; k++) &#123; f[p ^ 1][j][k] = min(f[p ^ 1][j][k], f[p][j][k] + abs(t[i] - s[i + 1])); f[p ^ 1][t[i]][k] = min(f[p ^ 1][t[i]][k], f[p][j][k] + abs(j - s[i + 1])); f[p ^ 1][j][t[i]] = min(f[p ^ 1][j][t[i]], f[p][j][k] + abs(k - s[i + 1])); &#125; &#125; &#125; for (int i = 1; i &lt;= h; i++) &#123; for (int j = 1; j &lt;= h; j++) &#123; ans = min(ans, f[n &amp; 1][i][j]); &#125; &#125; printf("%d\n", ans + sum); return 0;&#125; T3 数字卡片 问题描述 奶牛 BessieBessieBessie 收到了 FarmerJohnFarmer JohnFarmerJohn 送的一盒由 0∼90∼90∼9 组成的数字卡片。 FarmerJohnFarmer JohnFarmerJohn 想考考 BessieBessieBessie，于是让她用这些数字卡片摆出一个数字，要求：这个数字的长度大于等于 333，没有前导零，且任意连续三位组成的数字都是 333 的倍数。比如 156415641564 就是一个 满足要求的数字，因为 156156156 和 564564564 都是 333 的倍数。121212, 015015015, 156215621562 就是不满足要求的数字。 BessieBessieBessie 很快地解决了这个问题，FarmerJohnFarmer JohnFarmerJohn 只好加大问题的难度：用现有的卡片能摆出多少个不同的满足要求的数字？ BessieBessieBessie 先统计了一下每一张卡片的个数，用 c0c_0c0​, c1c_1c1​, . . . , c9c_9c9​ 分别来表示数字 000, 111, . . . , 999 的个数。接下来，她就来请教你了。请你帮她统计一下答案。 输入描述 输入仅一行，包含〸个数字 c0,c1,...,c9c_0, c_1, . . . , c_9c0​,c1​,...,c9​ 输出描述 输出一个数，表示符合要求的数字的个数对 109+710^9 + 7109+7 取模的结果。 输入样例 #111 1 2 3 0 0 0 0 0 0 0 #222 1 1 1 1 1 1 1 1 1 1 #333 1 2 3 4 5 6 7 8 9 10 输出样例 #111 11 #222 17076 #333 612513622 样例解释 对于第一组样例，符合要求的数一共有 111111 个：102102102, 120120120, 201201201, 210210210, 222222222, 102110211021, 120112011201, 201220122012, 210221022102, 120121201212012, 210212102121021. 数据范围 对于 30%30\%30% 的数据，1≤c0+c1+⋅⋅⋅+c9≤101 ≤ c0 + c1 + · · · + c9 ≤ 101≤c0+c1+⋅⋅⋅+c9≤10； 对于 60%60\%60% 的数据，1≤max{c0,c1,⋅⋅⋅,c9}≤101 ≤ max\{c0, c1, · · · , c9\} ≤ 101≤max{c0,c1,⋅⋅⋅,c9}≤10； 对于 100%100\%100% 的数据，1≤max{c0,c1,⋅⋅⋅,c9}≤1001 ≤ max\{c0, c1, · · · , c9\} ≤ 1001≤max{c0,c1,⋅⋅⋅,c9}≤100.]]></content>
      <categories>
        <category>习题</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>模拟考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭州集训Day5总结]]></title>
    <url>%2F2019%2F10%2F05%2Fhang-zhou-day5%2F</url>
    <content type="text"><![CDATA[国庆杭州集训Day5上午考试，一套奇奇怪怪的伪 USACOUSACOUSACO 的题目，（我也不知道是还没找到原题还是真的老师故意出这种题面），涵盖了数论、DPDPDP、模运算等内容，考场发挥不佳，故作总结。 T1 求和 问题描述 给定两个长度为 nnn 的数列，有两种操作 000 xxx yyy zzz 表示将 aaa 数组第 xxx 个元素修改为 yyy，bbb 数组第 xxx 个元素修改为 zzz 111 lll rrr 表示询问 ∑l≤i&lt;j≤rai×bj\sum \limits_{l \le i &lt; j \le r}a_i \times b_jl≤i&lt;j≤r∑​ai​×bj​ 输入描述 第一行两个正整数 nnn,mmm，第二行 nnn 个数 a1,a2,…,ana_1,a_2,…,a_na1​,a2​,…,an​，第三行 nnn 个数 b1,b2,…,bnb_1,b_2,…,b_nb1​,b2​,…,bn​ 接下来 mmm 行，表示 mmm 次操作 输出描述 对于每个询问操作，输出答案。 输入样例 5 31 2 3 4 51 2 3 4 51 2 40 3 6 61 2 4 输出样例 2644 数据范围 对于 30%30\%30% 的数据，n,m≤100n, m ≤ 100n,m≤100 对于 50%50\%50% 的数据，n,m≤4000n, m ≤ 4000n,m≤4000 另有 20%20\%20% 的数据保证没有修改操作 另有 20%20\%20% 的数据保证 ai=bia_i = b_iai​=bi​ 对于 100%100\%100% 的数据，n,m≤105,1≤ai,bi≤104n, m ≤ 10^5, 1 \le a_i, b_i \le 10^4n,m≤105,1≤ai​,bi​≤104 T1 总结、题解 总结 题解 代码 T2 武器 问题描述 一共有 nnn 种武器，直接购买成本为 aia_iai​。有 mmm 种合成方法，可以将 xxx,yyy 两种各一个武器合成一个 zzz 武器，请问获得第 nnn 种武器的最小成本和获得最小成本的方案数。 输入描述 输入的第一行包含两个正整数 nnn，mmm 表示武器数量和合成方法数量。 接下来一行包含 nnn 个正整数，其中 aia_iai​ 表示第 iii 件物品的成本。 接下来 mmm 行每行三个正整数 xxx, yyy , zzz，表示可以将一个 xxx, yyy 合为一个 zzz。 最后一行输入一个整数 typetypetype，如果 type=0type=0type=0 输出最小成本；如果 type=1type=1type=1 则输出最小成本和获得最小成本的方案数。 输出描述 如果 type=0type=0type=0 输出一个整数，表示获得第 nnn 种武器的最小成本。 如果 type=1type=1type=1 输出两个整数，分别表示获得第 nnn 种武器的最小成本和获得最小成本的方案数。 输入样例 7 35 6 3 2 2 3 101 2 74 5 13 6 21 输出样例 10 3 样例解释 第一种情况：用 444、555 合成 111，再用 111、222 合成 777 第二种情况：用 444、555 合成 111，用 333、666 合成 222，再用 111、222 合成 777 第三种情况：只用一个物品 777 这三种情况合成物品 777 的成本均为 101010。 数据范围 对于 20%20\%20% 的数据， n≤10,m≤20n \le 10,m \le 20n≤10,m≤20； 对于 60%60\%60% 的数据， n≤500,m≤1000n \le 500,m \le 1000n≤500,m≤1000； 对于 100%100\%100% 的数据， n≤5×104,m≤105;ai≤2×108n \le 5 \times 10^4, m \le 10^5; a_i \le 2 \times 10^8n≤5×104,m≤105;ai​≤2×108; 对于每部分的数据，有一半 type=0type=0type=0，一半 type=1type=1type=1。 T2 总结、题解 总结 题解 代码 T3 棋盘 问题描述 给定一个n×m(n,m&gt;1)n\times m(n,m&gt;1)n×m(n,m&gt;1)的棋盘，从左下角 (1,1)(1,1)(1,1) 走到右上角 (n,m)(n,m)(n,m)。每次只能向右或向上走。其中有 kkk 个棋子，要求不能经过这 kkk 个棋子。棋盘上还存在一条河流，满足 y−x=m−t(1&lt;=t&lt;=m)y-x=m-t(1&lt;=t&lt;=m)y−x=m−t(1&lt;=t&lt;=m),不能跨过这条河流（可以经过）。请问方案数为多少。 输入描述 第一行包含四个正整数 nnn, mmm, kkk, ttt 表示迷宫的大小、棋子的个数、河流的位置。 接下来的 kkk 行，每行有两个正整数 xix_ixi​, yiy_iyi​ 表示棋子的位置(保证起点终点不存在棋子) 输出描述 输出一个整数，表示方案数。（答案可能很大，要求答案对 109+710^9 + 7109+7 取模） 输入样例 4 5 1 33 4 输出样例 10 数据范围 对于 20%20\%20% 的数据， n,m,t,k≤10n,m,t,k \le 10n,m,t,k≤10； 对于 40%40\%40% 的数据， n,m,t,k≤1000n,m,t,k \le 1000n,m,t,k≤1000； 另有 20%20\%20% k=0k = 0k=0 另有 20%20\%20% t=1t = 1t=1 对于 100%100\%100% 的数据， n,m,t≤106;k≤104n,m,t \le 10^6; k \le 10^4n,m,t≤106;k≤104;]]></content>
      <categories>
        <category>习题</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>模拟考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划基本类型总结]]></title>
    <url>%2F2019%2F07%2F29%2Fdp%2F</url>
    <content type="text"></content>
      <categories>
        <category>算法解析</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07.29考试总结]]></title>
    <url>%2F2019%2F07%2F29%2F07-29-kao-shi%2F</url>
    <content type="text"><![CDATA[201920192019年777月292929日模拟考，考后总结。 数列游戏 题目描述 给定一个长度为 nnn 的序列 AiA_iAi​ ，从中任意删除若干个数字，试求删除数字后能够满足 Ai=iA_i=iAi​=i 的数量。 输入格式 第一行输入一个整数 nnn 第二行 nnn 个整数，第 iii 个数表示 AiA_iAi​ 输出格式 一行，一个整数，表示擦掉某些数后，最后剩下的数列中最多能有多少个数满足 Ai=iA_i=iAi​=i。 输入样例 51 1 2 5 4 输出样例 3 说明 &amp; 提示 删除第 222 个数字，有 A1=1,A2=2,A4=4A_1=1,A_2=2,A_4=4A1​=1,A2​=2,A4​=4 ，共 333 个 对于20%20\%20%的数据，n≤20n≤20n≤20; 对于60%60\%60%的数据，n≤100n≤100n≤100; 对于100%100\%100%的数据，n≤l000n≤l000n≤l000。 #include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;using namespace std;const int inf = 1e9 + 7;const int maxn = 5000 + 10;int n, ans;int f[maxn], a[maxn];inline int read() &#123; int s = 0, f = 0; char ch = getchar(); while (!isdigit(ch)) f |= ch == '-', ch = getchar(); while (isdigit(ch)) s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + (ch ^ 48), ch = getchar(); return f ? -s : s;&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 1; i &lt;= n; i++) &#123; for (int j = i; j &gt;= 1; j--) &#123; if (a[i] == j) f[j] = max(f[j], f[j - 1] + 1); else f[j] = max(f[j], f[j - 1]); &#125; &#125; for (int i = 1; i &lt;= n; i++) ans = max(ans, f[i]); printf("%d\n", ans); return 0;&#125; 公交车路线 题目描述 现有一个环型公路 A,B,C,D,E,F,G,HA,B,C,D,E,F,G,HA,B,C,D,E,F,G,H ，公交车从 AAA 出发，经过 nnn 次转移后到达 EEE ，中途不能到达 EEE ，且每次只能转移到相邻的车站，试求总方案数。 输入格式 一行一个整数 nnn 输出格式 一行一个整数，表示总方案数，答案对 100000710000071000007 取模 输入样例 6 输出样例 8 样例解释 存在以下 8 种方案 A→B→C→D→C→D→EA→B→C→B→C→D→EA→B→A→B→C→D→EA→H→A→B→C→D→EA→H→G→F→G→F→EA→H→G→H→G→F→EA→H→A→H→G→F→EA→B→A→H→G→F→EA→B→C→D→C→D→E\\ A→B→C→B→C→D→E\\ A→B→A→B→C→D→E\\ A→H→A→B→C→D→E\\ A→H→G→F→G→F→E\\ A→H→G→H→G→F→E\\ A→H→A→H→G→F→E\\ A→B→A→H→G→F→EA→B→C→D→C→D→EA→B→C→B→C→D→EA→B→A→B→C→D→EA→H→A→B→C→D→EA→H→G→F→G→F→EA→H→G→H→G→F→EA→H→A→H→G→F→EA→B→A→H→G→F→E #include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int inf = 1e9 + 7;const int maxn = 1e7 + 10;const int mo = 1000;int n, num, ans;int f[maxn];inline int read() &#123; int s = 0, f = 0; char ch = getchar(); while (!isdigit(ch)) f |= ch == '-', ch = getchar(); while (isdigit(ch)) s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + (ch ^ 48), ch = getchar(); return f ? -s : s;&#125;int main() &#123; n = read() / 2; f[2] = 1; f[3] = 4; for (int i = 4; i &lt;= n; i++) f[i] = (4 * f[i - 1] % mo - 2 * f[i - 2] % mo + mo) % mo; printf("%d\n", f[n] * 2 % mo); return 0;&#125;]]></content>
      <categories>
        <category>习题</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>模拟考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路径算法介绍]]></title>
    <url>%2F2019%2F07%2F28%2Fzui-duan-lu%2F</url>
    <content type="text"><![CDATA[对于一张连通图，两点间有路径联通，其中权值和最小的路径即为这两点间的最短路径，最短路算法便是解决此类路径的算法。 如下图，点 111 到点 444 的最短路径即为 777，1→5→3→41 \to 5 \to 3 \to 41→5→3→4，那么如何求解？下面将介绍三种关于求解最短路的算法。 Floyd算法 什么是Floyd Floyd算法是计算图中任意两点的最短路，其本质为动态规划，时间复杂度为 O(n3)O(n^3)O(n3)。 算法分析 对于点 iii 与点 jjj，我们可以用 f[i][j]f[i][j]f[i][j] 来表示 iii 到 jjj之间的最短路径, 对于已有的最短路中, 若存在一点 kkk 使得 f[i][k]+f[k][j]&lt;f[i][j]f[i][k] + f[k][j] &lt; f[i][j]f[i][k]+f[k][j]&lt;f[i][j], 则 f[i][j]f[i][j]f[i][j] 的最短路可更新为 f[i][k]+f[k][j]f[i][k] + f[k][j]f[i][k]+f[k][j], 对此, 我们可以在 O(n3)O(n^3)O(n3) 的时间内, 通过枚举 i,j,ki, j, ki,j,k 来得出全图的最短路径。其转移方程可写作如下 f[i][j]=min⁡1≤k≤n(f[i][k]+f[k][j])f[i][j] = \min_{1\le k \le n}(f[i][k] + f[k][j]) f[i][j]=1≤k≤nmin​(f[i][k]+f[k][j]) 代码展示 &amp;esp;我们先预处理题目给出的边,未相连的边初值为 infinfinf 即可。 for (int k = 1 ; k &lt;= n; k++) for (int i = 1 ; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) f[i][j] = min(f[i][j], f[i][k] + f[k][j]); 模板题 洛谷 P2910 寻宝之路 给定一条路径，每段路径有一个危险值，求路径上危险值之和最小为多少。（Floyd模板题） Dijkstra算法 什么是Dijkstra DijkstraDijkstraDijkstra 算法是用来计算一个点到另外所有点的最短路算法，即单源最短路算法，时间复杂度上限为O(n2)O(n^2)O(n2)(朴素)，在实际应用中较为稳定；加上堆优化之后更是具有 O((n+m)log⁡2n)O((n+m)\log_{2}n)O((n+m)log2​n) 的时间复杂度,在稠密图中有不俗的表现。 代码展示 下面给出堆优化的代码： #include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int inf = 1e9 + 7;const int maxn = 100000 + 10;int n, m, s, tot;int head[maxn], vis[maxn], dis[maxn];struct node&#123; int to, next, dis;&#125;edge[maxn * 2];priority_queue &lt; pair &lt;int, int&gt; &gt; q;void add(int x, int y, int z) &#123; edge[++tot].next = head[x]; edge[tot].to = y; edge[tot].dis = z; head[x] = tot;&#125;inline int read() &#123; int s = 0, f = 0; char ch = getchar(); while (!isdigit(ch)) f |= ch == '-', ch = getchar(); while (isdigit(ch)) s = (s&lt;&lt;3) + (s&lt;&lt;1) + (ch^48), ch = getchar(); return f ? -s : s;&#125;void dijkstra() &#123; for (int i = 1; i &lt;= n; i++) dis[i] = inf; dis[s] = 0; q.push(make_pair(0, s)); while (q.size()) &#123; int x = q.top().second; q.pop(); if (vis[x]) continue; vis[x] = 1; for (int i = head[x]; i; i = edge[i].next) &#123; int a = edge[i].to, b = edge[i].dis; if (dis[a] &gt; dis[x] + b) &#123; dis[a] = dis[x] + b; q.push(make_pair(-dis[a], a)); &#125; &#125; &#125;&#125;int main() &#123; n = read(), m = read(), s = read(); for (int i = 1; i &lt;= m; i++) &#123; int x = read(), y = read(), z = read(); add(x, y, z); &#125; dijkstra(); for (int i = 1; i &lt;= n; i++) printf("%d ", dis[i]); return 0;&#125; 模板题 洛谷 P3371【模板】单源最短路径（弱化版） 洛谷 P4779【模板】单源最短路径（标准版）]]></content>
      <categories>
        <category>算法解析</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>SPFA</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划——背包问题]]></title>
    <url>%2F2019%2F07%2F27%2Fbei-bao%2F</url>
    <content type="text"><![CDATA[距离NOIP2019NOIP2019NOIP2019仅剩下百余天，故以此总结一些必要算法，也算是补坑了 背包 背包问题基本问题为：给你 nnn 件物品和一个容量为 vvv 的背包。第 iii 件物品的费用是 c[i]c[i]c[i]，价值是 w[i]w[i]w[i], 即装入第 iii 件物品消耗 c[i]c[i]c[i] 的容积，收益为 w[i]w[i]w[i]。求解将哪些物品装入背包可使价值总和最大。 一、01背包问题 模型简介 01背包最基本的背包模型，即：每种物品仅有一件，可以选择取或者不取。 模型分析 对于转移的状态，用 f[i][j]f[i][j]f[i][j] 表示前表示前 iii 件物品恰放入一个容量为 vvv 的背包可以获得的最大价值。则其状态转移方程便是： f[i][j]=max{f[i−1][j],f[i−1][j−c[i]]+w[i]}f[i][j] = max\{f[i - 1][j], f[i - 1][j - c[i]] + w[i]\} f[i][j]=max{f[i−1][j],f[i−1][j−c[i]]+w[i]} 简单解读这个转移方程，为了获取当前状态 f[i][j]f[i][j]f[i][j] 的最优值，考虑从前面的状态进行转移，对于第 iii 个物品，显然只有选或不选两种情况存在，f[i\−1][j] 即是不选的情况，此时背包所装的容量不变，无需增加收益。而对于后一种状态，则是将第 iii 个物品装进背包的情况，由于当前的耗费的容量为 jjj 且当前装进物品的代价为 w[i]w[i]w[i] ，那么就应该从耗费容量为 j\−w[i] 处开始向当前状态转移。 由此转移方程就不难写出该模型的代码了: for (int i = 1; i &lt;= n; i++) for (int j = v; j &gt;= c[i]; j--) f[i][j] = max(f[i - 1][j], f[i - 1][j - c[i]] + w[i]); 优化空间 以上方法的时间和空间复杂度均为 O(N∗V)O(N*V)O(N∗V) ，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到 O(V)O(V)O(V)。 我们看到转移方程：f[i][j]=max{f[i−1][j],f[i−1][j−c[i]]+w[i]}f[i][j] = max\{f[i - 1][j], f[i - 1][j - c[i]] + w[i]\}f[i][j]=max{f[i−1][j],f[i−1][j−c[i]]+w[i]}，不难发现在转移过程中，仅与第 iii 项与 i−1i-1i−1 项有关系，于是我们可以考虑去掉数组的一维，以此来节省空间，代码如下，复杂度降至 O(v)O(v)O(v)： for (int i = 1; i &lt;= n; i++) for (int j = v; j &gt;= c[i]; j--) f[j] = max(f[j], f[j - c[i]] + w[i]); 模板题： 洛谷 P1048 采药 洛谷 P1049 装箱问题 洛谷 P2639 Bessie的体重问题 二、完全背包模型 模型简介 同样是背包的基础模型，与 010101 背包模型不同的是，完全背包模型中物品都可以取无限次。 模型分析。 状态设计与01背包相同，我们直接考虑转移: f[i][v]=max{f[i−1][v−k∗c[i]]+k∗w[i]∣0≤k∗c[i]≤v}f[i][v]=max\{f[i-1][v-k*c[i]]+k*w[i] | 0 \le k*c[i] \le v\} f[i][v]=max{f[i−1][v−k∗c[i]]+k∗w[i]∣0≤k∗c[i]≤v} 由此转移方程就不难写出该模型的代码了: for (int i = 1; i &lt;= n; i++) for (int j = v; j &gt;= c[i]; j--) for (int k = 0; k &lt;= j / c[i]; k++) f[i][j] = max(f[i][j], f[i - 1][j - k * c[i]] + k * w[i]); 复杂度分析与优化 不难从上面呢的代码中发现，这种处理完全背包的方式的时间复杂度为 O(nV)O(nV)O(nV) ，但与01背包不同的是，完全背包还存在一个常数 O(Vc[i])O(\frac{V}{c[i]})O(c[i]V​) ，并不理想，考虑优化。 一种方式是删除物品，即对于任意两个物品 iii，jjj ，若存在关系 c[i]&lt;c[j]c[i]&lt;c[j]c[i]&lt;c[j] 成立的同时也有 v[j]&lt;v[i]v[j]&lt;v[i]v[j]&lt;v[i] 成立 ，那么物品 jjj 就可以被删除掉，因为 jjj 的 “性价比” 更低 这个优化的预处理复杂度是 O(n2)O(n2)O(n2) 的，一般情况下可以接受，且对于随机数据有着较高的效率，但面对刻意设计的数据，极有可能出现一个物品都无法删除的情况，白白浪费了时间。 另一种优化思路，是先将收益大于 VVV 的物品去除，在计算出代价相同的物品的最大收益，预处理复杂度 O(n+V)O(n+V)O(n+V) 这两种简单的优化思路思维难度较低，且优化程度不明，均通过预处理来试图降低转移时的枚举量，但是在实际运行中有时并不能时实际运行时间降低，下面将引出两种运用01背包的思路来优化完全背包的方法 二进制拆分 虽然完全背包每一种物品都能取无限多次，但在背包空间的限制情况下，显然对于第 iii 种物品，最多能取 p=Vc[i]p = \frac{V}{c[i]}p=c[i]V​ 次，我们对 ppp 个物品 iii 进行二进制拆分，将其转化为代价为 2k×c[i]2^k×c[i]2k×c[i] 且收益为 2k×w[i]2^k×w[i]2k×w[i] 的若干个物品，此时已经将问题从完全背包模型转换为了01背包模型，可套用01背包模型求解 O(VN)的算法 与01背包的优化类似，现在我们压掉数组的第一维，得到下面的代码： for(int i = 1; i &lt;= n; i++) for(int j = c[i]; j &lt;= v; j++) f[j] = max(f[j], f[j - c[i]] + w[i]); 其转移方程为 f[i][j]=max{f[i−1][j] ,f[i][j−c[i]]+w[i]}f[i][j]=max\{f[i-1][j]\,,f[i][j-c[i]]+w[i]\} f[i][j]=max{f[i−1][j],f[i][j−c[i]]+w[i]} 模板题： 洛谷 P2722 总分 洛谷 P1679 神奇的四次方数 三、多重背包模型 模型简介 同样是背包的基础模型，与 010101 背包模型不同的是，多重背包模型中物品只可以取有限次。即物品数量是有限的。 模型分析。 这题目和完全背包问题很类似。只需将完全背包问题的方程略微一改即可，因为对于第 iii 种物品有 n[i]+1n[i]+1n[i]+1种策略：取 000 件，取 111 件……取 n[i]n[i]n[i] 件。令 f[i][v]f[i][v]f[i][v] 表示前 iii 种物品恰放入一个容量为 vvv 的背包的最大权值，则有状态转移方程： f[i][v]=max{f[i−1][v−k∗c[i]]+k∗w[i]∣0≤k≤n[i]}f[i][v]=max\{f[i-1][v-k*c[i]]+k*w[i] | 0 \le k \le n[i]\} f[i][v]=max{f[i−1][v−k∗c[i]]+k∗w[i]∣0≤k≤n[i]} 其复杂度为 O(V∗Σn[i])O(V*Σn[i])O(V∗Σn[i])。: 优化空间 类似的，我们同样可以将其空间压缩至一维，得到以下代码： for (int i = 1; i &lt;= n; i++) for (int j = V; j &gt;= 0; j--) for (int k = 1; k &lt;= c[i]; k++) f[j] = max(f[j], f[j - a[i] * k] + b[i] * k); 模板题： 洛谷 P2722 总分 洛谷 P1679 神奇的四次方数]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07.18模拟考试总结]]></title>
    <url>%2F2019%2F07%2F17%2F07-17-kao-shi%2F</url>
    <content type="text"><![CDATA[今日考试出了这题，被虐的死去活来 (说白了就是不会写) 。在听完讲解后收获颇丰，既然没有题解那就来写 (水) 一篇吧。 题目描述 VasilyVasilyVasily有一个栅栏，你可以将它看做由 nnn 个垂直的木板组成。每个木板的宽为 111 个单位，从左到右第 iii 块木板高为 hihihi 个单位。现在这些木板都是彼此相连构成了一个完整的栅栏。 由于VasilyVasilyVasily厌倦了这种布局，他希望将某些木板砍去一部分。要求满足以下限制条件： 1. 砍去的部分只能是木板的上部。(否则栅栏就立不起来了) 2. 砍去的部分必须相连（只有上下左右四个方向算相连，左上角等不算相连）。 3. 每块木板只能砍去整数单位的高度和 111 个单位的宽度。 4. 不能将某块木板全部砍去，即每块木板至少保留 111 个单位的高度。（这样才能保证剩余的木板依旧能构成一个完整的栅栏） 现在VasilyVasilyVasily想知道他有多少种砍的方案。由于这个数可能很大，你需要输出它对 100000000710000000071000000007 取模后的答案。 分析 对于题目，由于必须保留一行，我们可以事先将所有的 hhh 减一，就不要考虑最后一行不能拆的限制了。 然后，对于此题，不难看出是一道动态规划问题，由于 1&lt;=n&lt;=10000001&lt;=n&lt;=10000001&lt;=n&lt;=1000000 ,我们只能考虑 O(n)O(n)O(n) 的转移。对于第 iii 列 , 如何判断其拆卸的高度？考虑到对于任何一列，只有位于一段中最左端，中间，与最右端，如下图：lll即左端栅栏，rrr即右端栅栏。 不难得出，当其位于左端时，其可拆除高度仅仅只与本身与下一列的高度的最小值有关，即 f[l]=min(h[l],h[l+1])f[l] = min(h[l], h[l + 1])f[l]=min(h[l],h[l+1])。易得，当其位于中间时， f[i]=min(h[i−1],h[i],h[i+1])f[i] = min(h[i - 1], h[i], h[i + 1])f[i]=min(h[i−1],h[i],h[i+1]) ,右端同理。 由此，转移方程则可推出来，我们可用 f[i][0/1]f[i][0/1]f[i][0/1] 代表该栅栏拆的时候，0/10/10/1表示其后一列是否被拆除，111表示其被拆除，000表示没有。那么有： f[1][0]=h[1];f[1][0] = h[1];f[1][0]=h[1]; f[1][1]=min(h[1],h[2]);f[1][1] = min(h[1], h[2]);f[1][1]=min(h[1],h[2]); 而对于余下部分，则可有其位于中间，与位于左端之和得出 f[i][1]=min(h[i−1],h[i],h[i+1])∗f[i−1][1]+min(h[i],h[i+1])f[i][1] = min(h[i - 1], h[i], h[i + 1]) * f[i - 1][1] + min(h[i], h[i + 1])f[i][1]=min(h[i−1],h[i],h[i+1])∗f[i−1][1]+min(h[i],h[i+1]) f[i][0]=min(h[i−1],h[i])∗f[i−1][1]+h[i]f[i][0] = min(h[i - 1], h[i]) * f[i - 1][1] + h[i]f[i][0]=min(h[i−1],h[i])∗f[i−1][1]+h[i] 最终， ans=∑i=1nf[i][0]ans = \sum\limits_{i = 1}^{n}f[i][0]ans=i=1∑n​f[i][0] 。还有对于此题，由于其数据很大，对于模数的处理还需多加小心。 就这样，愉快的解决了此题，附代码： #include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int mo = 1e9 + 7;const int maxn = 1000000 + 100;int n, m, k, ans;int h[maxn], f[maxn][2];inline int read() &#123; int s = 0, f = 0; char ch = getchar(); while (!isdigit(ch)) f |= ch == '-', ch = getchar(); while (isdigit(ch)) s = (s&lt;&lt;3) + (s&lt;&lt;1) + (ch^48), ch = getchar(); return f ? -s : s;&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= n; i++) h[i] = read() - 1; // 预先减去1，方便后续操作 f[1][0] = h[1]; f[1][1] = min(h[1], h[2]); //初始化 for (int i = 2; i &lt;= n; i++) &#123; f[i][1] = (1ll * min(h[i - 1], min(h[i], h[i + 1])) * f[i - 1][1] + min(h[i], h[i + 1])) % mo; f[i][0] = (1ll * min(h[i - 1], h[i]) * f[i - 1][1] + h[i]) % mo; //转移 &#125; for (int i = 1; i &lt;= n; i++) ans = (ans + f[i][0]) % mo; //求和 printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP优化————前缀和优化]]></title>
    <url>%2F2019%2F07%2F17%2Fdp-qian-zhui-he%2F</url>
    <content type="text"><![CDATA[众所周知，动态规划在NOIPNOIPNOIP联赛中占有很重要的比例，而动态规划的优化则成为提升动态规划时间复杂度与空间复杂度的重要方法，近期有幸学习了几个优化方法，写点东西总结一下。 一、前缀和优化 前缀和，顾名思义，即前面iii个数的总和。例如NOIP2015NOIP2015NOIP2015提高组中，子串一题则运用了这种方法。 NOIP2015NOIP2015NOIP2015提高组 子串 题目描述 有两个仅包含小写英文字母的字符串AAA和BBB。 现在要从字符串AAA中取出kkk个互不重叠的非空子串，然后把这kkk个子串按照其在字符串AAA中出现的顺序依次连接起来得到一个新的字符串。请问有多少种方案可以使得这个新串与字符串BBB相等？由于答案可能很大，所以这里要求输出答案对 100000000710000000071000000007 取模的结果。 注意：子串取出的位置不同也认为是不同的方案。 说明 数据保证 1≤n≤1000,1≤m≤200,1≤k≤m1≤n≤1000,1≤m≤200,1≤k≤m1≤n≤1000,1≤m≤200,1≤k≤m。 有两个仅包含小写英文字母的字符串 AAA 和 BBB。 现在要从字符串 AAA 中取出 kkk 个互不重叠的非空子串，然后把这 kkk 个子串按照其在字符串 AAA 中出现的顺序依次连接起来得到一个新的字符串。请问有多少种方案可以使得这个新串与字符串 BBB 相等？ 注意：子串取出的位置不同也认为是不同的方案。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写代码的小女孩]]></title>
    <url>%2F2019%2F07%2F16%2Fthe-girl-who-write-code%2F</url>
    <content type="text"><![CDATA[天冷极了，下着雪，又快黑了。这是NOIP的前夜。在这又冷又黑的晚上，一个衣衫破烂的小女孩在机房敲着代码。她从班里逃出来的时候还拿着一本算导，但是有什么用呢？那是一本很破旧的书——那么大，一向是她妈妈垫桌角的。她默写SPFA的时候，年级主任突然冲进机房，吓得她把算导都丢掉了。书叫一个学数竞捡起来拿着跑了。他说，他可以用那本书当草纸，证明切比雪夫定理。小女孩只好自己写二叉堆，一双小脚冻得红一块青一块的。她面前的草纸堆得满满的，上面全是DP转移方程。这一整天，没有一个OJ让她AC一道题，她已经交了32遍采药了。 可怜的小女孩！她又冷又饿，浑身战栗地写着二叉堆。CRT显示器发出的光落在她的枯黄的长头发上，那干枯的头发打成卷儿披在肩上，看上去就像二叉树，不过她没注意这些。每个显示器里都透出光来，机房里飘着一股CPU发糊的怪味，因为这是NOIP前夜——她可忘不了这个。 她在主函数前面停了下来，蜷着趴在键盘上。她觉得更冷了。她不敢回家，因为她还没调完二叉堆，没写对一个DP方程，教练一定会骂她的。再说，换成别的数据结构，一样写不出来。这些题都太水，虽然神犇都写过题解了，但是题解上一般都只有三个字：傻X题。 她几乎绝望了。啊，哪怕一个函数不会RE，对她也是有好处的！她每写一遍程序，跑出来的结果就不一样，要是她有数据，她就知道哪一个程序是算对了的。她得不到数据了，因为机房上不去网了，全校的网速都让隔壁的年级主任拿来下小电影了。如果能保证下一个程序能AC，她就敢再写几十KB的代码，但是她是不敢啊，她怕又算出来一个奇葩的结果来。 她新建了一个cpp重写了程序。编译通过了了，样例过了。这次，她感觉自己站在IOI的考场中AK。学校的大门上，贴着“我校学生以国际金牌向110周年校庆献礼”的条幅。在班级内的非诚勿扰中，全班男生都给她留了灯。这时候，程序又RE了，她面前只有cmd上的黑底白字。 她又写了一道模拟。这一回，她坐在美丽的二叉堆下。这棵二叉堆，比她在丽洁代码中看到的常数还要小，还要短。眼前是许多优美动人的ASCII码，那些都是她写的程序，各种可爱的指针在跳跃着，满世界都是系统栈，都在向她眨眼睛。小女孩向眼前的系统栈伸出手去。这时候，眼前的ASCII码还在，条幅还在，指针还在，年级主任还是和蔼地微笑着。只见那些代码那些指针越升越高越升越高，最后成了在天空中闪烁的星星。 有一颗星星落下来了，在天空中划出了一道细长的红光。 “有一个什么人快要死了。”小女孩说。唯一疼她的学姐保送之前告诉过她：一颗星星落下来，就有一个灵魂要到上帝那儿去了。她notepad++中又写了一个快排。这一回，她把能用的IDE都用了。学姐出现在亮光里，是那么温和，那么快乐。 “学姐！”小女孩叫起来，“啊！请把我带走吧！我知道，系统栈一溢出，您就会不见的，像那校门的条幅，浮点数的精度，循环队列的空间一个样，就会不见的！”她赶紧编译了5KB的高精度模板，要把学姐留住。一大把程序发出强烈的光，把机房照得跟白天一样明亮。学姐从来没有像现在这样温柔，这样美丽。她把小女孩抱起来，搂在怀里。她们俩在光明和快乐中飞走了，越飞越高，飞到那没有DP，没有图论，也没有数据结构的地方去了。第二天清晨，这个小女孩坐在机房里，两腮通红，嘴上带着微笑。她死了，在NOIP的前夜死了。NOIP Day1的太阳升起来了，照在她小小的尸体上。小女孩坐在那儿，显示器上还有一坨编译过的代码。“她想好好复习复赛。”人们说。谁也不知道她曾经看到过多么美丽的东西，她曾经多么幸福，跟着她学姐一起走向新世界的幸福中去。 星星之火，终将成燎原之势]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>心得</tag>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图简单介绍]]></title>
    <url>%2F2019%2F07%2F08%2Fer-fen-tu%2F</url>
    <content type="text"><![CDATA[典型二分图染色的基本操作，此题对学习二分图有很大的帮助，同时因为很多题解对此介绍不太详细，而且有些模拟算法有误，故写此篇，介绍一下二分图及其操作。 什么是二分图 二分图又称作二部图，是图论中的一种特殊模型。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。 G=(V, E)，其中G代表图，V代表这个图的所有顶点的集合，E代表这个图所有连线的集合。现如今如果能将V这个顶点集分成两个互不相交的子集A、B，E这个边集内所有边的两个顶点分别属于A、B两个子集的话，我们就称这个图为二分图。 结合下图，相信可以对二分图有一个初步的了解。 二分图最大配 在图论中，匹配是指两两没有公共点的边集。 二分图最大匹配指：给出一个二分图，找一个边数最大的匹配，即选择尽量多的边，使得任意两条选中的边均没有公共点。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hash利器——康托展开]]></title>
    <url>%2F2019%2F03%2F09%2Fa%2F</url>
    <content type="text"><![CDATA[最近又重新来写神奇的八数码题目，发现中间hash用到了康托展开，于是在百度的帮助下来介绍一下康托展开～ #include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;stack&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int mo = 19260817;int n, m, x, y, num;int a[1000010];int f[] = &#123;1,1,2,6,24,120,720,5040,40320,362880&#125;;inline int read() &#123; int s = 0, f = 0; char ch = getchar(); while (!isdigit(ch)) f |= ch == '-', ch = getchar(); while (isdigit(ch)) s = (s&lt;&lt;3) + (s&lt;&lt;1) + (ch^48), ch = getchar(); return f ? -s : s;&#125;int cantor(int num[], int n) &#123; int ans = 0, sum = 0; for (int i = 1; i &lt; n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; if (a[i] &gt; a[j]) sum++; &#125; ans += sum * f[n - i]; sum = 0; &#125; return ans + 1;&#125;int main() &#123; freopen("luogu.in", "r", stdin); n = read(); for (int i = 1; i &lt;= n; i++) scanf("%1d", &amp;a[i]); printf("%d\n", cantor(a, n)); return 0;&#125;]]></content>
      <tags>
        <tag>康托展开</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流————最大流问题]]></title>
    <url>%2F2019%2F01%2F13%2Fzui-da-liu%2F</url>
    <content type="text"><![CDATA[1 #include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;cctype&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;const int inf=19260817;int n,m,s,t;int p[10010],vis[10010],e[2010][2010];inline int read()&#123; int f=0,s=0; char ch=getchar(); while(!isdigit(ch)) f|=ch=='-',ch=getchar(); while(isdigit(ch)) s=(s&lt;&lt;3)+(s&lt;&lt;1)+(ch^48),ch=getchar(); return f?-s:s;&#125;int bfs(int s,int t)&#123; queue &lt;int&gt; q; memset(vis,0,sizeof(vis)); p[s]=s; vis[s]=1; q.push(s); while(!q.empty())&#123; int x=q.front();q.pop(); for(int i=1;i&lt;=m;i++)&#123; if(e[x][i] &amp;&amp; !vis[i])&#123; p[i]=x; vis[i]=1; if(i==t) return 1; q.push(i); &#125; &#125; &#125; return 0;&#125;int ek(int s,int t)&#123; int ans=0; while(bfs(s,t))&#123; int d=inf; for(int i=t;i!=s;i=p[i]) d=min(d,e[p[i]][i]); for(int i=t;i!=s;i=p[i])&#123; e[p[i]][i]-=d; e[i][p[i]]+=d; &#125; ans+=d; &#125; return ans;&#125;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++)&#123; int u=read(),v=read(),w=read(); e[u][v]=w; &#125; printf("%d\n",ek(1,m)); return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元旦欢乐%你赛解析]]></title>
    <url>%2F2018%2F12%2F30%2Fyun-dan-huan-le-sai%2F</url>
    <content type="text"><![CDATA[戊戌年12月30日夜，大雪纷飞，当日，元旦模拟赛举行… (编不下去了) T1 全民皆兵 问题描述 由于突如其来的外来入侵，地球防卫总部大大放宽了银河战队的选拔条件，现在紧急向全世界选拔银河战士来保卫地球。终于，从世界巡回海选中有n个人脱颖而出，每一个人都有一个较高的战斗值。地球防卫总部要求在最后选出来的人中任何两个人都必须是没有一点关系的（包括亲戚关系），这样才能保证在战场上每位战士都能心无杂念地奋勇杀敌。可恰恰不幸的是，在这n个人当中，有某一些人具有一些很遥远的亲戚关系，比如A的父亲的父亲的父亲的父亲（……）与B的母亲的母亲的母亲的母亲（……）是夫妻，那么就说A与B有亲戚关系。再说明白点，比如A和B有亲戚关系，B和C有亲戚关系，那么A和C就有亲戚关系（算法也太清晰了吧……）。而现在地球防卫总部急想在1秒钟的时间内知道这n个人能组成多大的军队以及在保证人数最大的情况下的军队的最大战斗力（指军队中每个战士的战斗值之和）是多少，所以就把这个任务叫给了号称“编程天才”的你来解决。 输入说明 第一行一个数n；（30%的数据n&lt;=10；100%的数据n&lt;=300000；） 第二行n个数，第i个数表示第i战士的战斗值； 接下来若干行(行数&lt;=n)，每行两个数Ai和Bi，表示Ai和Bi两位战士具有微妙的亲戚关系。 输入数据保证不出现Ai=Bi的情况，但一种情况多次出现是允许的，谁叫他们两太亲呢！ 答案保证在longint范围内。 输出说明 共两行，每行一个数； 第一行为最大军队人数； 第二行为军队的最大战斗力。 样例输入 10291 2306 668 2710 1524 1318 602 2991 2881 29514 69 44 79 110 17 101 9 样例输出 510440 T2 通讯线路 问题描述 某地区共有n座村庄，每座村庄的坐标用一对整数(x, y)表示，现在要在村庄之间建立通讯网络。通讯工具有两种，分别是需要铺设的普通线路和卫星设备。卫星设备数量有限，只能给k个村庄配备卫星设备。拥有卫星设备的村庄互相间直接通讯；铺设了线路的村庄之间也可以通讯。卫星分配是不受限制的。 问怎样合理的分配卫星和铺设线路，使得在保证每两座村庄之间都可以直接或间接地通讯的前提下，铺设线路的总长度最短。 输入说明 第一行两个数：n，k（0≤k≤n≤2000） 接下来n行，每行两个整数(x,y)数描述一个村庄。（-10000≤x,y≤10000） 输出说明 仅一行，代表总长度，精确到0.0001 样例输入 20 8137 824761 1468 151194 758149 138314 90809 404964 877471 66177 54673 977397 560928 653199 486736 44985 801621 509444 14088 508556 327 样例输出 1355.4195 T3 墙壁粉刷 问题描述 现在需要粉刷一列墙壁，墙壁被分成n段，为了节约用钱，科学家决定只粉刷其中一些段，同是为了美观，科学家要求每连续的m段墙壁中至少有两块被粉刷，现在已知粉刷每一段墙壁的费用。科学家要你帮他求出最少的费用。 输入说明 第一行，n和m（2&lt;=n &lt;=10000，2&lt;=m&lt;=100） 第二行，n个非负整数，第i个数为粉刷第ｉ段的费用。（费用&lt;=10000） 输出说明 一行，最小费用。 样例输入 8 36 7 10 1 7 8 5 6 样例输出 30]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>2018</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2008提高组——双栈队列]]></title>
    <url>%2F2018%2F11%2F27%2FTG2008-shuan-zhan-dui-lie%2F</url>
    <content type="text"><![CDATA[典型二分图染色的基本操作，此题对学习二分图有很大的帮助，同时因为很多题解对此介绍不太详细，而且有些模拟算法有误，故写此篇，介绍一下二分图及其操作。 什么是二分图 二分图又称作二部图，是图论中的一种特殊模型。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。 G=(V, E)，其中G代表图，V代表这个图的所有顶点的集合，E代表这个图所有连线的集合。现如今如果能将V这个顶点集分成两个互不相交的子集A、B，E这个边集内所有边的两个顶点分别属于A、B两个子集的话，我们就称这个图为二分图。 结合下图，相信可以对二分图有一个初步的了解。 什么是染色 就是给对象标记一种“颜色”，其主要作用是便于分类，而不是实现真正意义上的染色。 故我们可以创建一个数组，每个数组的下标对应一个元素，数组的每个元素的值代表该对象标记的颜色。如此，就完成了染色这一步骤。 我们可以通过建立二维数组e[MAX][MAX]来实现二分图。二维数组的横向代表A顶点子集，纵向代表B顶点子集。如若两个顶点i,j有连接，则在对应的e[i][j] 与 e[j][i]处赋值为1。 我们可以通过dfs进行染色验证，判断其是否为二分图。 二分图的条件：通过深度优先搜索对每个顶点进行染色，如果相邻顶点颜色相同或者是同一顶点出现染不同颜色的情况，则说明该图不是二分图。 题目解析 此题题意还是很明确的，通过两个栈来进行排序操作，并且找出最小值。 方法便是二分图染色。对数字串进行两个两个逐次遍历，如果符合规则的便将二者连接起来，则当遍历结束后完成构图。然后通过dfs染色，确立真正的二分图。然后借助染色表(记录每个元素颜色的数组)，进行相应的push(), pop()操作，最终便能完成排序。具体规则如下： 对于任意两个数t[i]和t[j],它们不能压入同一个栈中的充要条件: 存在一个k,使得i&lt;j&lt;k且t[k]&lt;t[i]&lt;t[j]。 证明 ：利用反证法，假设当这t[i]，t[j]压入了同一个栈，那么压入t[k]，因为t[k]&lt;t[i]&lt;t[j]，显然，当t[k]没有被弹出的时候，另两个数也都不能被弹出，否则不符题意。而又因t[j]总是会在t[i]之前弹出，但t[j]&gt;t[i]，矛盾，所以假设不成立。 由此，我们便可根据这些来解决此题了。 #include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;cmath&gt;#define maxn 1004using namespace std;const int inf=19260817;int n,num;int color[maxn];int t[maxn]; //要排序的元素的存储int s[maxn]; //判断两个数字是否满足规则bool flag,e[maxn][maxn];void paint(int x,int c)&#123; //DFS进行染色 color[x]=c; for(int i=1;i&lt;=n;i++)&#123; if(e[x][i])&#123; //查找相邻点 if(color[i]==c) flag=false; //若相邻点颜色相同，则错误 if(!color[i]) paint(i,3-c); //若未染过色，对其染色，3-c结果为1,2，表示1与2号栈 &#125; &#125;&#125;void make()&#123; //创造二分图 s[n+1]=inf; for(int i=n;i&gt;=1;i--)&#123; s[i]=t[i]; if(s[i+1]&lt;s[i]) s[i]=s[i+1]; &#125; for(int i=1;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if(t[i]&lt;t[j] &amp;&amp; s[j+1]&lt;t[i])&#123; e[i][j]=e[j][i]=1; //按规则创建图 &#125; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; if(!color[i])&#123; //染色 paint(i,1); &#125; &#125;&#125;void work()&#123; if(flag==false)&#123; printf("0\n"); return ; &#125; stack&lt;int&gt; stack1,stack2; int now=1; for(int i=1;i&lt;=n;i++)&#123; if(color[i]==1)&#123; //入栈 stack1.push(t[i]); printf("a "); &#125; else &#123; stack2.push(t[i]); printf("c "); &#125; while((!stack1.empty() &amp;&amp; stack1.top()==now) || (!stack2.empty() &amp;&amp; stack2.top()==now))&#123; //判断是否弹出 if(!stack1.empty() &amp;&amp; stack1.top()==now)&#123; stack1.pop(); now++; printf("b "); &#125; else&#123; stack2.pop(); now++; printf("d "); &#125; &#125; &#125;&#125;int main()&#123; flag=1; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;t[i]); &#125; make(); work(); return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>2008</tag>
        <tag>提高组</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2008题解报告]]></title>
    <url>%2F2018%2F11%2F17%2FNOIP2008%E9%A2%98%E8%A7%A3%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[Oh !!! T1 #include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;cctype&gt;using namespace std;int n,m,minn=19260817,maxx=-19260817;int num[27];char s[110];bool pd(int x)&#123; if(x==1 || x==0) return 0; for(int i=2;i&lt;=sqrt(x);i++) if(x%i==0) return 0; return 1;&#125;int main()&#123; cin&gt;&gt;s; for(int i=0;i&lt;strlen(s);i++)&#123; num[s[i]-'a'+1]++; &#125; for(int i=1;i&lt;=26;i++)&#123; if(num[i]!=0 &amp;&amp; num[i]&gt;maxx) maxx=num[i]; if(num[i]!=0 &amp;&amp; num[i]&lt;minn) minn=num[i]; &#125; if(pd(maxx-minn)) printf("Lucky Word\n%d\n",maxx-minn); else printf("No Answer\n0\n"); return 0;&#125; Oh !!! T2 #include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;cctype&gt;using namespace std;int k,m,n,sum;int a[10]=&#123;6,2,5,5,4,5,6,3,7,6&#125;;int work(int x)&#123; int num=0; while(x/10!=0)&#123; num+=a[x%10]; x/=10; &#125; return num+a[x];&#125;int main()&#123; scanf("%d",&amp;n); n=n-4; for(int i=0;i&lt;=1111;i++)&#123; for(int j=0;j&lt;=1111;j++)&#123; if(work(i)+work(j)+work(i+j)==n) sum++; &#125; &#125; printf("%d",sum); return 0;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>历届真题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018提高组游记]]></title>
    <url>%2F2018%2F11%2F11%2F2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[不在爆零中爆发，就在爆零中灭亡。 ———鲁迅 其实根本说不上是游记，因为我就在省城，还是离考点最近的学校… Day0]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在Linux上玩Minecraft]]></title>
    <url>%2F2018%2F11%2F11%2Fmc%2F</url>
    <content type="text"><![CDATA[Minecraft作为一款高自由度沙盒游戏，想必很多人在Windows上面玩得很开心，由于辣鸡网易收购了Minecraft，导致国服只能通过网易，然而我们Linux上也不是不可以玩，下面带你开启划水之旅。 Step 1.下载HMCL启动器 这里，当然是选择Linux版本的啦！ Step 2.卸载系统自带Java(openJDK) 执行命令 sudo apt-get remove openjdk* Step 3.下载Java 8(oracle-java8) 这里，选择Linux x64 Step 4.安装Java 8(oracle-java8) 接下来有点难度了。所有路径自己选，只不过要自己对应修改。*是你下载的java版本号。 在图中选择位置的下划线后面的数字。 1.解压缩并移动 解压缩文件夹到桌面，cd到桌面，输入命令 sudo mv jre1.8.0_*/ /usr/local/ 2.配置环境变量 输入命令 sudo gedit /etc/environment 在末尾复制以下内容 JAVA_HOME="/usr/local/jre1.8.0_*"CLASSPATH="$JAVA_HOME/lib"PATH＝"$JAVA_HOME/bin" 3.安装jre环境 输入命令 sudo update-alternatives --install /usr/bin/java java /usr/local/jre1.8.0_*/bin/java 300 此时应该已经成功，输入命令检测 java -version 如果出现的是java而不是openJDK则说明安装成功！！跳过下一步。 4.选择正确jre 输入命令 sudo update-alternatives --config java 按照提示选择你刚刚安装的Java。 Step 5.启动HMCL启动器 cd到启动器目录，就是那个单文件，建议单独新建一个文件夹。 输入命令 java -jar 再来一个tab自动补全~~(美滋滋)~~，反正就是那个带HMCL的文件。 然后。。。就没有然后了！！ 后记 1.Java有两种，一种openjdk，一种oracle java，直接无法使用的原因应该是系统自带的是openjdk这种并不太普及的Java。 2.可以试试在不卸载自带Java的情况下安装Java 8，即跳过Step 2，也许就需要进行Step 4的第4部分。 3.运行过程中请不要关闭终端，如果嫌弃终端，请尝试以下命令 nohup java -jar HMCL-3.2.112.jar &amp; 也许你的文件名字不一样，请合理利用好tab自动补全。 4.成果展示]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>不务正业</tag>
      </tags>
  </entry>
</search>
